# 데이터 정규화 및 ERD 설계 업데이트



## 1. 정규화를 진행한 이유



초기 분석 단계에서는 단일 테이블(`cleaned_data`)을 기반으로



EDA, RFM 분석, 퍼널 분석 등 대부분의 분석을 수행하였다.



이 방식은 분석 속도와 구현 측면에서는 효율적이었지만,



아래와 같은 구조적 한계를 가지고 있었다.



- 고객, 주문, 상품 정보가 한 테이블에 혼재

- 동일한 고객/상품 정보가 반복 저장됨

- 데이터 무결성 관리가 어려움

- 테이블 구조 확장 시 유지보수 비용 증가



이에 따라 **분석 단계 이후 데이터 구조를 정리하고,

실무 환경에 가까운 데이터 모델을 구성하기 위해 정규화를 진행**하였다.



---



## 2. 정규화 설계 개요 (3NF)



정규화는 **3차 정규형(3NF)**을 목표로 진행하였으며,



거래 데이터를 아래 4개 테이블로 분리하였다.



- `customers` : 고객 마스터

- `orders` : 주문(거래) 헤더

- `order_items` : 주문 상세(라인 아이템)

- `products` : 상품 마스터



이 구조를 통해



- 데이터 중복을 제거하고

- 각 엔티티의 책임을 명확히 분리하며

- 분석 및 확장에 유리한 구조를 확보하였다.

> 주문상품(order_items) 테이블을 중심 Fact Table로 두고

> 고객, 주문, 상품 테이블을 Dimension으로 구성한 형태이다.




---



## 3. ERD 구조 설명



관계는 다음과 같이 구성된다.



- 고객(`customers`) 1명 → 여러 주문(`orders`)

- 주문(`orders`) 1건 → 여러 주문상품(`order_items`)

- 상품(`products`) 1개 → 여러 주문상품(`order_items`)



```

customers 1 ─── N orders
orders    1 ─── N order_items
products  1 ─── N order_items

```



이는 실제 커머스/리테일 데이터베이스에서 사용하는



전형적인 거래 모델 구조이다.



---



## 4. 분석 호환을 위한 VIEW 재구성



정규화 이후에도 기존 분석 로직(SQL, Python)이 정상 동작하도록



정규화된 테이블을 다시 조합한 **분석용 VIEW**를 생성하였다.



대표적으로:



- `analysis_base`

- `rfm_customer_segments_v2`

- `segment_product_purchases`

- `segment_product_summary` 등



이 VIEW들은 정규화된 테이블을 JOIN하여



기존 `cleaned_data`와 유사한 형태로 데이터를 제공하도록 설계되었다.



---



## 5. VIEW 업데이트 과정에서 발생한 문제



### 5.1 컬럼명 불일치 문제



정규화 과정에서 테이블 컬럼명을 **snake_case**로 통일하면서



기존 VIEW 및 분석 코드에서 사용하던 컬럼명과 불일치가 발생하였다.



예시:



- `customerid` → `customer_id`

- `invoiceno` → `invoice_no`

- `unitprice` → `unit_price`



이로 인해 기존 VIEW를 `CREATE OR REPLACE VIEW`로 재생성할 때



컬럼명 변경 오류 및 의존성 문제가 발생하였다.



---



### 5.2 PostgreSQL VIEW 교체 제약



PostgreSQL에서는 `CREATE OR REPLACE VIEW` 사용 시:



- 컬럼 이름 변경 ❌

- 컬럼 타입 변경 ❌



이라는 제약이 존재한다.



이로 인해:



- 기존 VIEW를 참조하는 다른 VIEW가 있는 경우

- 컬럼명을 직접 변경하면 오류가 발생



---



## 6. 해결 전략 (점진적 마이그레이션)



본 프로젝트에서는 **기존 분석 코드의 안정성을 유지하기 위해**



아래 전략을 사용하였다.



1\. 정규화된 테이블에서는 snake_case 유지

2\. 기존 VIEW는 legacy 컬럼명 유지

3\. JOIN 시에만 컬럼명 매핑 수행

&nbsp;   - 예: `rcs.customerid = ab.customer_id`



이를 통해:



- 기존 분석 파이프라인 유지

- 정규화 구조 도입

- 점진적 마이그레이션 가능



---



## 7. 정규화 이후의 효과



- 데이터 중복 제거 및 무결성 향상

- 고객/상품/주문 단위 분석 명확화

- RFM, 퍼널, 상품 분석 확장 용이

- 실무 환경과 유사한 데이터 모델링 경험 축적



---



## 8. 요약



> 본 프로젝트에서는
> 초기 분석 중심의 단일 테이블 구조에서
> 실무 확장성을 고려한 정규화 구조로 전환하였다.
> 정규화 이후에도 기존 분석 결과를 유지하기 위해
> VIEW 기반의 점진적 마이그레이션 전략을 적용하였다.

